#!/usr/bin/env bash
###############################################################################
# 01_run_compleasm_from_metadata_v9.sh
#
# PURPOSE
#   Run Compleasm on genomes listed in a metadata CSV, extract CDS sequences,
#   and generate a summary metadata.csv linking species names to outputs.
#
# OUTPUT METADATA (metadata.csv)
#   Headers:
#     genus_species,full_table,cds_fasta
#
#   Where:
#     - genus_species : lowercase Genus_species derived from organism_name
#     - full_table    : path to compleasm full_table.tsv
#     - cds_fasta     : path to *_cds_compleasm.fasta generated by
#                       get_cds_from_compleasm_v6.py
#
# USAGE
#   bash 01_run_compleasm_from_metadata_v9.sh <query|allgenomes> [options]
#
# ARGUMENTS
#   <query>       Accession OR organism name (case-insensitive, underscores ok)
#   allgenomes    Run Compleasm on all genomes in the metadata CSV
#
# OPTIONS
#   -t INT        Number of threads to use (default: 8)
#   -l STR        BUSCO/Compleasm lineage folder name (default: sauropsida_odb12)
#   -f            Force re-run even if outputs already exist (archives existing lineage dir)
#   -h            Print this help message and exit
#
# EXAMPLES
#   # Run a single species
#   bash 01_run_compleasm_from_metadata_v9.sh podarcis_muralis -t 7
#
#   # Run all genomes in the metadata file
#   bash 01_run_compleasm_from_metadata_v9.sh allgenomes -t 10
#
# REQUIREMENTS
#   - Conda environment with:
#       compleasm (tested: 0.2.6)
#       miniprot  (tested: 0.18)
#       hmmer     (tested: 3.4)
#   - BUSCO lineage directory present (e.g. sauropsida_odb10 or odb12)
#   - genomes_metadata.csv with columns:
#       accession, organism_name, path_to_fna
#
# NOTES
#   - If expected outputs already exist (miniprot_output.gff, full_table.tsv, *_cds_compleasm.fasta),
#    the script will SKIP re-running miniprot/compleasm for that genome and will only (re)write metadata.csv.
#  - Partial/incomplete outputs will be archived and regenerated.
#   - This script uses manual miniprot + compleasm analyze (Option A).
#     This avoids Compleasm's internal miniprot parsing issues we hit on odb10,
#     and also works for odb12.
###############################################################################

set -euo pipefail

METADATA_CSV="/Users/rossoaa/projects/genomes/records/genomes_metadata.csv"

# Directory that CONTAINS lineage folders (e.g. contains sauropsida_odb10/, sauropsida_odb12/)
LINEAGES_DIR="/Users/rossoaa/projects/genomes/records/compleasm/busco_lineages/mb_downloads"

# Default lineage; override like:
#   LINEAGE_ID=sauropsida_odb10 bash 01_run_compleasm_from_metadata_v9.sh podarcis_muralis
#   bash 01_run_compleasm_from_metadata_v9.sh podarcis_muralis -l sauropsida_odb10
LINEAGE_ID="${LINEAGE_ID:-sauropsida_odb12}"

OUT_ROOT="/Users/rossoaa/projects/genomes/records/compleasm"
THREADS="${THREADS:-8}"
FORCE_RERUN="${FORCE_RERUN:-0}"


# Output metadata table (written fresh each run)
METADATA_OUT="${METADATA_OUT:-${OUT_ROOT}/metadata.csv}"

# Python script to extract CDS from the compleasm full_table
# Default assumes get_cds_from_compleasm_v6.py sits next to this bash script.
GET_CDS_PY="${GET_CDS_PY:-$(dirname "$0")/02a_get_cds_from_compleasm_v6.py}"

# Optional: override miniprot/hmmsearch if needed
MINIPROT_BIN="${MINIPROT_BIN:-}"
HMMSEARCH_BIN="${HMMSEARCH_BIN:-}"

# Optional: miniprot --outs cutoff
OUTS="${OUTS:-0.85}"

QUERY="${1:-}"
shift || true

while getopts ":t:l:fh" opt; do
  case "$opt" in
    t) THREADS="$OPTARG" ;;
    l) LINEAGE_ID="$OPTARG" ;;
    f) FORCE_RERUN=1 ;;
    h)
      echo "Usage: $(basename "$0") <query|allgenomes> [-t threads] [-l lineage] [-f]"
      echo "Defaults: -l sauropsida_odb12, -t 8"
      echo "Env overrides: LINEAGE_ID=..., OUTS=..., MINIPROT_BIN=..., HMMSEARCH_BIN=..."
      echo ""
      echo "ENVIRONMENT EXPECTATIONS"
      echo "  - For odb12 lineages: activate conda env: compleasm_env (recommended) "
      echo "  - For odb10 lineages: activate conda env: compleasm_v026"
      echo "The script will warn if your active conda env does not match the lineage."
      exit 0
      ;;
    \?) echo "ERROR: invalid option -$OPTARG" >&2; exit 2 ;;
    :)  echo "ERROR: option -$OPTARG requires an argument" >&2; exit 2 ;;
  esac
done

if [[ -z "$QUERY" ]]; then
  echo "ERROR: missing argument (<query> or allgenomes)" >&2
  exit 2
fi

mkdir -p "$OUT_ROOT" "$LINEAGES_DIR"

# Check lineage exists
if [[ ! -d "${LINEAGES_DIR}/${LINEAGE_ID}" ]]; then
  echo "ERROR: lineage directory not found: ${LINEAGES_DIR}/${LINEAGE_ID}" >&2
  echo "       (Make sure you extracted the tarball into LINEAGES_DIR)" >&2
  exit 1
fi

# Find compleasm
if command -v compleasm >/dev/null 2>&1; then
  COMPLEASM="compleasm"
elif command -v compleasm.py >/dev/null 2>&1; then
  COMPLEASM="compleasm.py"
else
  echo "ERROR: compleasm not found in PATH. Activate the appropriate env (compleasm_env for odb12; compleasm_v026 for odb10)." >&2
  exit 1
fi

# Find miniprot
if [[ -z "$MINIPROT_BIN" ]]; then
  if command -v miniprot >/dev/null 2>&1; then
    MINIPROT_BIN="$(command -v miniprot)"
  else
    echo "ERROR: miniprot not found in PATH (and MINIPROT_BIN not set)." >&2
    exit 1
  fi
fi

# Find hmmsearch
if [[ -z "$HMMSEARCH_BIN" ]]; then
  if command -v hmmsearch >/dev/null 2>&1; then
    HMMSEARCH_BIN="$(command -v hmmsearch)"
  else
    echo "ERROR: hmmsearch not found in PATH. Install hmmer in this env." >&2
    exit 1
  fi
fi


# Sanity-check: active conda env vs lineage (non-fatal warning)
if [[ -n "${CONDA_DEFAULT_ENV:-}" ]]; then
  expected_env=""
  if [[ "$LINEAGE_ID" =~ _odb12$ ]]; then
    expected_env="compleasm_env"
  elif [[ "$LINEAGE_ID" =~ _odb10$ ]]; then
    expected_env="compleasm_v026"
  fi

  if [[ -n "$expected_env" && "${CONDA_DEFAULT_ENV}" != "$expected_env" ]]; then
    echo "[WARN] Active conda env: ${CONDA_DEFAULT_ENV} (expected: ${expected_env} for ${LINEAGE_ID})" >&2
    echo "[WARN] If you see missing tools or odd Compleasm behavior, activate the expected env." >&2
  fi
fi

if [[ ! -f "$GET_CDS_PY" ]]; then
  echo "ERROR: Could not find CDS extraction script: $GET_CDS_PY" >&2
  echo "       Set GET_CDS_PY=/full/path/to/02a_get_cds_from_compleasm_v6.py" >&2
  exit 1
fi

# Initialize metadata output: only write header if the file doesn't exist
if [[ ! -f "$METADATA_OUT" ]]; then
  echo "genus_species,full_table,cds_fasta" > "$METADATA_OUT"
else
  echo "[Info] Appending to existing: $METADATA_OUT"
fi


#############################################
# Helper: append a row to metadata.csv if not already present
#############################################
append_metadata_row() {
  local genus_species="$1"
  local full_table="$2"
  local cds_fasta="$3"

  # If this exact combination already exists, skip.
  if grep -Fq "\"${genus_species}\",\"${full_table}\",\"${cds_fasta}\"" "$METADATA_OUT" 2>/dev/null; then
    return
  fi

  printf '"%s","%s","%s"\n' "$genus_species" "$full_table" "$cds_fasta" >> "$METADATA_OUT"
}


#############################################
# Helper: archive old compleasm results
#############################################
archive_if_exists() {
  # Archive one or more existing lineage run directories under an outdir.
  # Usage: archive_if_exists <outdir> [lineage_dirname]
  local outdir="$1"
  local which="${2:-}"

  local archive_root="${outdir}/archive"
  local ts
  ts="$(date +%Y-%m-%d_%H-%M-%S)"
  mkdir -p "$archive_root"

  if [[ -n "$which" ]]; then
    local d="${outdir}/${which}"
    if [[ -d "$d" ]]; then
      echo "[ARCHIVE] Moving existing ${which} -> ${archive_root}/${which}__archived_${ts}"
      mv "$d" "${archive_root}/${which}__archived_${ts}"
    fi
    return
  fi

  # Otherwise archive any odb10/odb12 lineage dirs we find.
  local existing
  existing="$(find "$outdir" -maxdepth 1 -type d \( -name "*_odb10" -o -name "*_odb12" \) 2>/dev/null || true)"
  if [[ -n "$existing" ]]; then
    while IFS= read -r d; do
      [[ -z "$d" ]] && continue
      local base
      base="$(basename "$d")"
      echo "[ARCHIVE] Moving existing ${base} -> ${archive_root}/${base}__archived_${ts}"
      mv "$d" "${archive_root}/${base}__archived_${ts}"
    done <<< "$existing"
  fi
}

#############################################
# Helper: run compleasm for one genome (Option A)
#############################################

run_one() {
  local accession="$1"
  local organism="$2"
  local genome="$3"

  if [[ -z "$genome" || ! -f "$genome" ]]; then
    echo "[WARN] Genome missing, skipping: $genome"
    return
  fi

  local safe_org
  safe_org="$(echo "$organism" | tr ' /' '__' | tr -cd '[:alnum:]_-.')"

  local outdir="${OUT_ROOT}/${accession}__${safe_org}"
  local lin_dir="${outdir}/${LINEAGE_ID}"
  local gff="${lin_dir}/miniprot_output.gff"
  local gff_tmp="${gff}.tmp"
  local miniprot_log="${lin_dir}/miniprot.stderr.log"
  local refdb="${LINEAGES_DIR}/${LINEAGE_ID}/refseq_db.faa.gz"

  # Derive genus_species from organism name (first two words)
  local genus_species
  genus_species="$(echo "$organism" | awk '{print $1"_"$2}' | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]_')"
  if [[ -z "$genus_species" ]]; then
    echo "ERROR: Failed to derive genus_species from organism: $organism" >&2
    exit 1
  fi

  mkdir -p "$outdir"
  mkdir -p "$lin_dir"


  #############################################
  # CHECK_EXISTING_OUTPUTS: if outputs exist for odb10 or odb12, skip re-running
  #############################################
  local preferred_lineage=""
  for cand in "${LINEAGE_ID}" "sauropsida_odb12" "sauropsida_odb10"; do
    [[ -z "$cand" ]] && continue
    local cand_dir="${outdir}/${cand}"
    local cand_gff="${cand_dir}/miniprot_output.gff"
    local cand_full=""
    local cand_cds="${cand_dir}/${genus_species}_cds_compleasm.fasta"

    if [[ -d "$cand_dir" ]]; then
      if [[ -f "${cand_dir}/full_table.tsv" ]]; then
        cand_full="${cand_dir}/full_table.tsv"
      elif [[ -f "${cand_dir}/full_table.csv" ]]; then
        cand_full="${cand_dir}/full_table.csv"
      else
        cand_full="$(ls -1 "${cand_dir}"/full_table.* 2>/dev/null | head -n 1 || true)"
      fi

      if [[ -s "$cand_gff" && -n "$cand_full" && -s "$cand_full" && -s "$cand_cds" ]]; then
        preferred_lineage="$cand"
        break
      fi
    fi
  done

  if [[ -n "$preferred_lineage" && "$FORCE_RERUN" -ne 1 ]]; then
    local pdir="${outdir}/${preferred_lineage}"
    local pfull=""
    if [[ -f "${pdir}/full_table.tsv" ]]; then
      pfull="${pdir}/full_table.tsv"
    elif [[ -f "${pdir}/full_table.csv" ]]; then
      pfull="${pdir}/full_table.csv"
    else
      pfull="$(ls -1 "${pdir}"/full_table.* 2>/dev/null | head -n 1 || true)"
    fi
    local pcds="${pdir}/${genus_species}_cds_compleasm.fasta"

    echo "[SKIP] Found existing outputs for ${accession} (${preferred_lineage}); not re-running."
    append_metadata_row "$genus_species" "$pfull" "$pcds"
    return
  fi

  # If current lineage dir exists but outputs are incomplete, archive it (unless forcing rerun does it anyway)
  if [[ -d "$lin_dir" && "$FORCE_RERUN" -ne 1 ]]; then
    local need_archive=0
    local have_gff=0 have_full=0 have_cds=0

    [[ -s "${lin_dir}/miniprot_output.gff" ]] && have_gff=1
    [[ -s "${lin_dir}/${genus_species}_cds_compleasm.fasta" ]] && have_cds=1
    if [[ -s "${lin_dir}/full_table.tsv" || -s "${lin_dir}/full_table.csv" ]]; then
      have_full=1
    fi

    if [[ "$have_gff" -ne 1 || "$have_full" -ne 1 || "$have_cds" -ne 1 ]]; then
      need_archive=1
    fi

    if [[ "$need_archive" -eq 1 ]]; then
      archive_if_exists "$outdir" "$LINEAGE_ID"
      mkdir -p "$lin_dir"
    fi
  fi

  # If force re-run requested, archive the current lineage dir before regenerating
  if [[ "$FORCE_RERUN" -eq 1 ]]; then
    archive_if_exists "$outdir" "$LINEAGE_ID"
    mkdir -p "$lin_dir"
  fi

  if [[ ! -f "$refdb" ]]; then
    echo "ERROR: refseq_db.faa.gz not found: $refdb" >&2
    exit 1
  fi

  echo "[RUN ] $accession | $organism | lineage=${LINEAGE_ID}"
  echo "[MINIPROT] $MINIPROT_BIN --outs=$OUTS -t $THREADS"
  echo "[MINIPROT] Writing: $gff_tmp"
  echo "[MINIPROT] STDERR : $miniprot_log"

  # Clean temp outputs (donâ€™t risk reading stale files)
  rm -f "$gff_tmp" "$miniprot_log"

  # prove we can write to the directory/file before running miniprot
  : > "$gff_tmp" || { echo "ERROR: cannot create $gff_tmp" >&2; exit 1; }
  echo "[DEBUG] preflight: created $gff_tmp" >&2
  
  # Run pipeline but do not let set -e kill us
  set +e
  "$MINIPROT_BIN" --trans -u -I --outs="$OUTS" -t "$THREADS" --gff "$genome" "$refdb" > "$gff_tmp" 2> "$miniprot_log"
  miniprot_rc=$?
  echo "[DEBUG] gff_tmp first non-comment lines:"
  grep -v '^#' "$gff_tmp" | head -n 5 || true
  set -e
  
  echo "[DEBUG] miniprot exit code: $miniprot_rc"
  echo "[DEBUG] gff_tmp bytes: $(wc -c < "$gff_tmp" 2>/dev/null || echo 0)"
  tail -n 20 "$miniprot_log" 2>/dev/null || true
  
  if [[ "$miniprot_rc" -ne 0 ]]; then
    echo "ERROR: miniprot failed" >&2
    exit 1
  fi

  ls -lh "$gff_tmp" "$miniprot_log" || true
  echo "[DEBUG] gff_tmp bytes: $(wc -c < "$gff_tmp" 2>/dev/null || echo 0)"
  echo "[DEBUG] gff_tmp first lines:"
  head -n 5 "$gff_tmp" 2>/dev/null || true
  
  # Validate: non-empty AND contains at least one feature line (not just headers)
  if [[ ! -s "$gff_tmp" ]]; then
    echo "ERROR: miniprot produced an empty GFF (stdout was empty)." >&2
    echo "       Temp: $gff_tmp" >&2
    echo "       See : $miniprot_log" >&2
    exit 1
  fi
  
  if ! grep -qv '^#' "$gff_tmp"; then
    echo "ERROR: miniprot GFF contains only comments/headers (no features)." >&2
    echo "       Temp: $gff_tmp" >&2
    echo "       See : $miniprot_log" >&2
    exit 1
  fi

  if ! grep -q $'\tminiprot\tmRNA\t' "$gff_tmp"; then
    echo "ERROR: miniprot GFF has no mRNA features (unexpected format/content)." >&2
    echo "       Temp: $gff_tmp" >&2
    echo "       Head:" >&2
    head -n 25 "$gff_tmp" >&2 || true
    echo "       See : $miniprot_log" >&2
    exit 1
  fi

  mv -f "$gff_tmp" "$gff"
  echo "[MINIPROT] OK: $(wc -c < "$gff") bytes -> $gff"

  echo "[ANALYZE] compleasm analyze -g <gff> -l ${LINEAGE_ID}"
  set -x
  "$COMPLEASM" analyze -g "$gff" -o "$outdir" -l "$LINEAGE_ID" -L "$LINEAGES_DIR" -t "$THREADS" --hmmsearch_execute_path "$HMMSEARCH_BIN"
  set +x

  # Locate the compleasm full table (created by `compleasm analyze`)
  local full_table="${outdir}/${LINEAGE_ID}/full_table.tsv"
  if [[ ! -f "$full_table" ]]; then
    # Some installations may write .csv; fall back to glob search
    if [[ -f "${outdir}/${LINEAGE_ID}/full_table.csv" ]]; then
      full_table="${outdir}/${LINEAGE_ID}/full_table.csv"
    else
      full_table="$(ls -1 "${outdir}/${LINEAGE_ID}"/full_table.* 2>/dev/null | head -n 1 || true)"
    fi
  fi
  if [[ -z "$full_table" || ! -f "$full_table" ]]; then
    echo "ERROR: Could not find compleasm full_table in: ${outdir}/${LINEAGE_ID}" >&2
    exit 1
  fi

  # Extract CDS FASTA from the compleasm full_table
  local cds_fasta="${outdir}/${LINEAGE_ID}/${genus_species}_cds_compleasm.fasta"
  echo "[CDS ] python3 $(basename "$GET_CDS_PY") <genome> <full_table> ${genus_species}"
  python3 "$GET_CDS_PY" "$genome" "$full_table" "$genus_species"
  if [[ ! -s "$cds_fasta" ]]; then
    echo "ERROR: CDS FASTA was not created or is empty: $cds_fasta" >&2
    exit 1
  fi

  # Append to metadata.csv
  append_metadata_row "$genus_species" "$full_table" "$cds_fasta"
}


#############################################
# Batch mode
#############################################
if [[ "$QUERY" == "allgenomes" ]]; then
  echo "[INFO] Running compleasm (Option A) on ALL genomes with lineage=${LINEAGE_ID}"
  awk -F',' '
    function trim(s){ gsub(/^[ \t"]+|[ \t"]+$/, "", s); return s }
    NR==1{ for(i=1;i<=NF;i++) h[trim($i)]=i; next }
    {
      acc=trim($(h["accession"]))
      org=trim($(h["organism_name"]))
      fna=trim($(h["path_to_fna"]))
      if(acc!="" && fna!="") print acc "\t" org "\t" fna
    }
  ' "$METADATA_CSV" |
  while IFS=$'\t' read -r acc org fna; do
    run_one "$acc" "$org" "$fna"
  done
  echo "[INFO] allgenomes run complete"
  exit 0
fi

#############################################
# Single-genome mode (robust species matching)
#############################################
match="$(
awk -F',' -v q="$QUERY" '
  function trim(s){ gsub(/^[ \t"]+|[ \t"]+$/, "", s); return s }
  function norm(s){ s=tolower(trim(s)); gsub(/[ \t_-]+/, "_", s); gsub(/[^a-z0-9_.]/, "", s); return s }
  BEGIN{ qn=norm(q) }
  NR==1{ for(i=1;i<=NF;i++) h[trim($i)]=i; next }
  {
    acc=trim($(h["accession"]))
    org=trim($(h["organism_name"]))
    fna=trim($(h["path_to_fna"]))
    if(acc==q || fna==q || norm(org)==qn)
      print acc "\t" org "\t" fna
  }
' "$METADATA_CSV"
)"

n=$(echo "$match" | awk 'NF{c++} END{print c+0}')
if [[ "$n" -ne 1 ]]; then
  echo "ERROR: Query matched $n rows; use accession for uniqueness." >&2
  echo "$match" >&2
  exit 1
fi

IFS=$'\t' read -r acc org fna <<< "$match"
run_one "$acc" "$org" "$fna"

echo "[INFO] Done"

